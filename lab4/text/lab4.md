# Лабораторная работа №4

## Как жать?

### Назначения кастомных файлов

1. ".gitignore" убирает лишние файлы из видимости Git
2. "start.sh" файл для демонстрации тестового задания (запускает все, )
3. "Sum/" - папка с заданиями 4 и 5 (там все так же)


### Так как жать?

1. Вводим команду "./start.sh" и СТАРТУЕМ

### Если нада жать сложна ( показать/посмотреть детали )

* Вводим команду "make parallel_min_max" и СТАРТУЕМ (компилит и линкует все задание 1)
* Вводим команду "make showcase" и СТАРТУЕМ (компилит задание 2)
* Переходим в "Sum/" водим команду "make sum" и СТАРТУЕМ (задания 5-6)

### Good links (Maybe better than in lab (better for shure))

#### Getopt:
* http://www.firststeps.ru/linux/r.php?11

#### Makefile:
* https://habr.com/en/post/155201/
* https://habr.com/en/post/211751/

#### Exec:
* https://www.geeksforgeeks.org/difference-fork-exec/
* https://www.softprayog.in/programming/creating-processes-with-fork-and-exec-in-linux

#### Signals:
https://aljensencprogramming.wordpress.com/2014/05/09/introduction-to-signals-using-alarm-in-linux-c/

#### How data work:
https://en.wikipedia.org/wiki/Data_segment#Data
https://rtfm.co.ua/linux-c-adresnoe-prostranstvo-processa/

#### Other:
http://citforum.ck.ua/programming/cpp_march/cpp_048.shtml
https://habr.com/en/sandbox/114114/

## Задание 1

### Необходимые знания

1. Функция `kill`
2. Неблокирующий wait c `WNOHANG`
3. Функция `alarm`, сигнал `SIGALRM`, функция `signal`.

Дополнить программу parallel\_min\_max.c из ***лабораторной работы №3***, так чтобы после заданного таймаута родительский процесс посылал дочерним сигнал SIGKILL. Таймаут должен быть задан, как именной необязательный параметр командной строки (`--timeout 10`). Если таймаут не задан, то выполнение программы не должно меняться.

### Ресурсы

1. [Системный вызов kill](http://man7.org/linux/man-pages/man2/kill.2.html)
2. [Системный вызов waitpid. Здесь информация о WNOHANG](https://linux.die.net/man/2/waitpid)
3. [Системный вызов signal](http://man7.org/linux/man-pages/man2/signal.2.html)
4. [Системный вызов alarm](http://man7.org/linux/man-pages/man2/alarm.2.html)

## Ответ

1. Функция `kill` - "насильно" завершает процесс
2. Неблокирующий wait c `WNOHANG` - означает неблокирующую проверку завершившихся дочерних процессов, для защиты от зомби
3. Функция `alarm`, сигнал `SIGALRM`, функция `signal`. - Сигнал истечения времени, заданного alarm()

## Задание 2

### Необходимые знания

1. Что такое зомби процессы, как появляются, как исчезают.

Создать программу, с помощью которой можно продемонстрировать зомби процессы. Необходимо объяснить, как появляются зомби процессы, чем они опасны, и как можно от них избавиться.

## Ответ

1. Зомби процессы - это дочерние процессы которые не могут завершиться из-за родительского, хоть и закончили все вычесления, тем самым засоряя таблицу активности. Заканчиваются с завершением родительского.


### Ресурсы

1. [Немного теории по зомби процессам](https://www-cdf.fnal.gov/offline/UNIX_Concepts/concepts.zombies.txt)

## Задание 3

### Необходимые знания

1. Работа виртуальной памяти.

Скомпилировать process_memory.c. Объяснить, за что отвечают переменные `etext`, `edata`, `end`.

### Ресурсы

1. [etext, edata, end](https://linux.die.net/man/3/edata)
2. [Неплохая статья (перевод), про то, как устроена память](https://habrahabr.ru/company/nixsolutions/blog/277759/)

## Ответ

1.
Программа это не просто кусок на плате памяти, у нее есть структура. Есть часть памяти с кодом программы (машинный код), есть память программы которая состоит из 3ех частей (кучи, и двух стеков, (динамическая и статическая))
etext адрес на конец "программного кода"
edata ссылка на инициализированную часть памяти
end - ссылка на свободную часть памяти

## Задание 4

Создать makefile, который собирает программы из задания 1 и 3.

## Задание 5

### Необходимые знания

1. POSIX threads: как создавать, как дожидаться завершения.
2. Как линковаться на бибилотеку `pthread`

Доработать parallel_sum.c так, чтобы:

* Сумма массива высчитывалась параллельно.
* Массив генерировался с помощью функции `GenerateArray` из ***лабораторной работы №3***.
* Программа должна принимать входные аргументы: количество потоков, seed для генерирования массива, размер массива (`./psum --threads_num "num" --seed "num" --array_size "num"`).
* Вместе с ответом программа должна выводить время подсчета суммы (генерация массива не должна попадать в замер времени).
* Вынести функцию, которая считает сумму в отдельную библиотеку.

### Ресурсы

1. [Туториал по POSIX threads от университета Карнеги-Меллона (в этой лабе вам нужно только начало)](https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html#SCHEDULING)
2. [Как можно мерить время (кстати в 3й лабораторной работе тоже есть пример)](https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html)

## Ответ

1. объявляются переменные ссылки для ссылок на POSIX threads (pthread_t threads[]), потом потоки создаются функцией "pthread_create", с передачей данных в виде аргументов (ссылки на потоки для работы с ними, служебный флаг, функция для выполнения, данные)
int pthread_create(pthread_t thread, const pthread_attr_t attr,
                   void (start_routine) (void ), void arg);
обрабатываются потоки функцией "pthread_join", которая возвращает служебное значения а принимает ссылки для получения информации и ссылки для потоков для обработки
int pthread_join(pthread_t thread, void retval);
2. Библиотека линкуется с включением файла "инклудом"


## Задание 6

Создать makefile для parallel_sum.c.

## Перед тем, как сдавать

Залейте ваш код в ваш репозиторий на GitHub. Убедитесь, что вы не добавляете в репозиторий бинарные файлы (программы, утилиты, библиотеки и т.д.).
